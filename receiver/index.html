<!DOCTYPE html>
<html>

<head>
	<title>chromecast-nes</title>
</head>
<link rel="stylesheet" type="text/css" href="css/style.css">

<body>
	<div id="nes-wrapper" class="nes-wrapper">
	</div>
</body>
<script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script src="js/peerjs.min.js"></script>
<script src="js/phaser.min.js"></script>
<script src="js/gameinput.js"></script>
<script src="js/syncableScene.js"></script>
<script src="js/game.js"></script>
<script>
	const namespace = 'urn:x-cast:se.patrikkarlsson.cast.snes-cast';
	let myPeer;
	let mainCastSenderId;
	let remotePeerConnected = false;
	let dataConnection;
	let context;
	let game;
	let gameInput = new GameInput();
	let parent = document.getElementsByClassName('nes-wrapper')[0];
	let sceneUpdater;

	window.onload = function () {
		const initialize = () => {
			console.log('initializing peer');
			myPeer = new Peer();
			myPeer.on('open', onOpen);
			myPeer.on('call', () => {
				console.log('We should not be called!');
			});
			myPeer.on('connection', onConnect);
			myPeer.on('close', onClose);
			myPeer.on('disconnected', onDisconnected);
			myPeer.on('error', onError);
			myPeer.connect();

			console.log('initializing cast');
			const options = new cast.framework.CastReceiverOptions();
			options.disableIdleTimeout = true;

			context = cast.framework.CastReceiverContext.getInstance();
			
			context.setLoggerLevel(cast.framework.LoggerLevel.DEBUG);
			context.addCustomMessageListener(namespace, onCustomMessage);

			context.addEventListener(cast.framework.events.EventType.SENDER_CONNECTED, onSenderConnected);
			context.addEventListener(cast.framework.events.EventType.READY, onCastReady);

			context.start(options);
			game = startGame(gameInput, parent);
			sceneUpdater = new PhaserRenderStateSceneUpdater(game);
		};

		const onCastReady = (event) => {
			findLaunchingSenderId();
		};

		const findLaunchingSenderId = () => {
			if (!mainCastSenderId && cast.framework.system.launchingSenderId) {
				mainCastSenderId = cast.framework.system.launchingSenderId;
				console.log('main cast sender: ' + mainCastSenderId);
			} else if (!mainCastSenderId) {
				console.log('unable to find launching sender id');
			}
		}

		const onConnect = (connection) => {
			if (dataConnection) {
				dataConnection.close();
			}
			dataConnection = connection;
			dataConnection.on('data', (data) => {
				const parsed = JSON.parse(data);
				
				if (parsed.type === 'b') {
					onButtonDataMessage(parsed);
				} else if (parsed.type === 'GS') {
					onGameStateMessage(parsed.o);
				}
			});
		};

		const onOpen = (id) => {
			console.log('Connected to Peer-server with id: ' + id);
			findLaunchingSenderId();
			trySendingPeerId();
		};

		const onClose = () => {
			console.log('Closed');
			myPeer.destroy();
		};

		const onDisconnected = () => {
			console.log('disconnected');
			if (!remotePeerConnected) {
				myPeer.reconnect();
			}
		};

		const onError = error => {
			console.log(error);
		};

		const onSenderConnected = (event) => {
			console.log(event);
			mainCastSenderId = event.senderID;
			trySendingPeerId();
		};

		const onSenderDisconnected = (event) => {
			console.log('sender disconnected');
			console.log(event);
			if (mainCastSenderId && event.senderID === mainCastSenderId) {
				mainCastSenderId = undefined;
			}
		}

		const trySendingPeerId = (senderId = undefined) => {
			console.log('trying to send local peer id');
			let id = senderId ? senderId : mainCastSenderId;
			if (myPeer.id && id && context && !remotePeerConnected) {
				context.sendCustomMessage(namespace, mainCastSenderId, { type: 'castPeerId', peerId: myPeer.id });
			} else {
				console.log('Failed to send local peer id...');
			}
		};

		function onCustomMessage(event) {
			if (event.data.type == 'sendPeerId') {
				console.log('Recieved request for sending local peer id from sender with id: ' + event.senderId)
				trySendingPeerId(event.senderId);
			} else if (event.data.type == 'ping') {
				console.log('Got pinged!');
			} else if (event.data.type === 'b') {
				onButtonDataMessage(event.data);
			} else if (event.data.type === 'GS') {
				onGameStateMessage(event.data.o)
			}
		}

		const onButtonDataMessage = (message) => {
			if (message.b === 'L') {
				gameInput.setLeftIsDown(message.a === 'D');
			} else if (message.b === 'R') {
				gameInput.setRightIsDown(message.a === 'D');
			}
		};

		const onGameStateMessage = (objects) => {
			sceneUpdater.renderStateObjects(objects);
		};

		initialize();
	};
</script>

</html>