<html data-cast-api-enabled="true">

<head>
  <title>chromecast-nes</title>
</head>
<link rel="stylesheet" type="text/css" href="css/style.css">

<body>
  <div class='center-column-flex'>
    <section>
      <h1>Choose casting device</h1>
      <div style="width: 44px; height: 44px;">
        <google-cast-launcher></google-cast-launcher>
      </div>
    </section>
  </div>
</body>
<script src="js/jquery-1.4.2.min.js"></script>
<script src="js/peerjs.min.js"></script>

<script>
  const applicationId = 'F1F2B4A5';
  const namespace = 'urn:x-cast:se.patrikkarlsson.cast.snes-cast';
  const PING_INTERVAL = 1000*60;
  const DEBUG = false;
  const USE_WEBRTC = false;

  let castPeerId;
  let castDataConnection;
  let myPeer;

  let castContext;
  let currentSession;
  let pingTimer;
  
  $(function () {
    console.log('initializing peer');
    myPeer = new Peer();
    myPeer.on('open', onOpen);
    myPeer.on('close', onClose);
    myPeer.on('disconnected', onDisconnected);
    myPeer.on('error', onError);
    myPeer.connect();
  });

  window['__onGCastApiAvailable'] = function (isAvailable) {
    if (isAvailable) {
      initializeCastApi();
    }
  };

  const initializeCastApi = function () {
    castContext = cast.framework.CastContext.getInstance();
    cast.framework.setLoggerLevel(cast.framework.LoggerLevel.DEBUG);
    castContext.setOptions({
      receiverApplicationId: applicationId,
      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
    });
    castContext.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, onCastStateChanged);
    castContext.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, onSessionStateChanged);
  };

  const onCastStateChanged = (event) => {
    console.log(event.data);
  };

  const onSessionStateChanged = (event) => {
    console.log(event);
    if ((event.sessionState === cast.framework.SessionState.SESSION_STARTED || event.sessionState === cast.framework.SessionState.SESSION_RESUMED) && event.session) {
      console.log('started');
      currentSession = event.session;
      currentSession.addMessageListener(namespace, onCustomMessage);
      launch();
    } else if (event.sessionState === cast.framework.SessionState.SESSION_START_FAILED) {
      console.log('failed to start session :(');
      cleanup();
    } else if (event.sessionState === cast.framework.SessionState.SESSION_ENDED) {
      cleanup();
    }
  };

  const onCustomMessage = (recievedNameSpace, message) => {
    if (recievedNameSpace !== namespace) {
      console.error('unexpected namespace');
      return;
    }
    let parsedMessage = JSON.parse(message);
    console.log('Recieved message: ' + JSON.stringify(parsedMessage));

    if (parsedMessage.type == 'castPeerId') {
        setCastPeerId(parsedMessage.peerId);
    } else {
      console.log('unhandled custom message');
      console.log(message);
    }
  };

  const pingCast = () => {
    if (currentSession) {
      console.log('Pingin the cast');
      currentSession.sendMessage(namespace, { type: 'ping' });
    }
  };

  const getCastPeerId = () => {
    if (currentSession) {
      currentSession.sendMessage(namespace, { type: 'sendPeerId' }); 
    }
  };

  const isConnected = (connection) => {
    return connection && connection.open === true;
  }

  const setCastPeerId = (id) => {
    console.log('Setting castPeerId');
    castPeerId = id;
    if (castPeerId && isConnected(castDataConnection) === false && USE_WEBRTC === true) {
      castDataConnection = myPeer.connect(castPeerId);
    }
  }

  const launch = function () {
    if (currentSession || DEBUG) {
      console.log("running");

      getCastPeerId();
      if (!pingTimer) {
          pingTimer = setInterval(() => { pingCast(); }, PING_INTERVAL);
      }
    } else {
      cleanup();
    }
  };

  const onOpen = (id) => {
    console.log('Connected to Peer-server with id: ' + id);
  };

  const onClose = () => {
    console.log('Closed');
    cleanup();
    myPeer.destroy();
  };

  const onDisconnected = () => {
    console.log('disconnected');
    if (!castPeerId) {
      myPeer.reconnect();
    }
  };

  const onError = error => {
    console.log(error);
  };

  const cleanup = () => {
    console.log('Cleaning up');
    castPeerId = null;
    if (pingTimer) {
      clearInterval(pingTimer);
      pingTimer = null;
    }
    if (currentSession) {
      currentSession.removeMessageListener(namespace, onCustomMessage);
    }
    if (castDataConnection) {
      castDataConnection.close();
      castDataConnection = null;
    }
  };

  if (DEBUG) {
    launch();
  }
</script>
<script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>

</html>