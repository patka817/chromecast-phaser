<html data-cast-api-enabled="true">

<head>
  <title>chromecast-Breakout</title>
</head>
<link rel="stylesheet" type="text/css" href="css/style.css">

<body>
  <section class='center-column-flex'>
    
      <h1>Choose casting device</h1>
      <div style="width: 44px; height: 44px;">
        <google-cast-launcher></google-cast-launcher>
      </div>
    
      <button id='pause'>Pause/Resume</button>
    
    <section class='buttonContainer'>
      <div class='left'></div>
      <div class='right'></div>
    </section>
  </section>
</body>
<script src="js/jquery-1.4.2.min.js"></script>
<script src="js/peerjs.min.js"></script>
<script src="js/phaser.min.js"></script>
<script src="js/latencyChecker.js"></script>
<script src="js/gameinput.js"></script>
<script src="js/gamepad.js"></script>
<script src="js/phaserRenderStateManager.js"></script>
<script src="js/game.js"></script>
<script>
  const applicationId = 'F1F2B4A5';
  const namespace = 'urn:x-cast:se.patrikkarlsson.cast.snes-cast';
  const DEBUG = false;
  const USE_WEBRTC = true;

  let isHost = true; // kinda not used...

  let castPeerId;
  let castDataConnection;
  let myPeer;

  let castContext;
  let currentSession;

  let gamepad;
  let headlessGame;
  let renderStateManager;
  let latencyChecker = new LatencyChecker();
  
  $(function () {
    console.log('initializing peer');
    myPeer = new Peer();
    myPeer.on('open', onOpen);
    myPeer.on('close', onClose);
    myPeer.on('disconnected', onDisconnected);
    myPeer.on('error', onError);
    myPeer.connect();

    document.getElementById('pause').onclick = () => {
      if (!headlessGame) {
        showConnectAlert();
        return;
      }
      if (paused() === true) {
        resumeGame();
      } else {
        pauseGame();
      }
    };

    const left = document.getElementsByClassName('left')[0];
    const right = document.getElementsByClassName('right')[0];
    gamepad = new GamePad(left, right, (ac, buttonCode) => {
      if (!isHost) {
        sendButtonMessage(ac, buttonCode);
      }
    });
    gamepad.disabled = true;
  });

  window['__onGCastApiAvailable'] = function (isAvailable) {
    if (isAvailable) {
      initializeCastApi();
    }
  };

  const initializeCastApi = function () {
    castContext = cast.framework.CastContext.getInstance();
    cast.framework.setLoggerLevel(cast.framework.LoggerLevel.DEBUG);
    castContext.setOptions({
      receiverApplicationId: applicationId,
      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
    });
    castContext.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, onCastStateChanged);
    castContext.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, onSessionStateChanged);
  };

  const onCastStateChanged = (event) => {
    console.log(event.data);
  };

  const onSessionStateChanged = (event) => {
    console.log(event);
    if ((event.sessionState === cast.framework.SessionState.SESSION_STARTED || event.sessionState === cast.framework.SessionState.SESSION_RESUMED) && event.session) {
      console.log('started');
      currentSession = event.session;
      currentSession.addMessageListener(namespace, onCustomMessage);
      launch();
    } else if (event.sessionState === cast.framework.SessionState.SESSION_START_FAILED) {
      console.log('failed to start session :(');
      cleanup();
    } else if (event.sessionState === cast.framework.SessionState.SESSION_ENDED) {
      cleanup();
    }
  };

  const onCustomMessage = (recievedNameSpace, message) => {
    if (recievedNameSpace !== namespace) {
      console.error('unexpected namespace');
      return;
    }
    let parsedMessage = JSON.parse(message);
    if (parsedMessage.type == 'castPeerId') {
        setCastPeerId(parsedMessage.peerId);
    } else if (parsedMessage.type === 'LC') {
      latencyChecker.onRecievedAnswer(parsedMessage);
    } else {
      console.log('unhandled custom message');
      console.log(message);
    }
  };

  let lastAlert;
  const showConnectAlert = () => {
    if (!lastAlert || (lastAlert && ((new Date()).getTime() - lastAlert.getTime() > 1000*5))) {
      lastAlert = new Date();
      alert('Connect to the chromecast to be able to play');
    }
  };

  const sendButtonMessage = (action, button) => {
    let payload = {type: 'b', a: action, b: button };
    sendCastMessage(payload);
  }

  const sendGameStateMessage = (gameDTOs) => {
    let state = { type: 'GS', o: gameDTOs };
      sendCastMessage(state);
  };

  const sendCastMessage = (payload) => {
    if (USE_WEBRTC) {
      if (isConnected(castDataConnection)) {
          castDataConnection.send(JSON.stringify(payload))
      } else if (currentSession) {
        // ???! TODO:
      } else {
        showConnectAlert();
      }
    } else if (currentSession) {
      currentSession.sendMessage(namespace, payload).catch(error => {
        console.log(error);
      });
    } else {
      showConnectAlert();
    }
  };

  const getCastPeerId = () => {
    if (currentSession) {
      currentSession.sendMessage(namespace, { type: 'sendPeerId' }); 
    }
  };

  const isConnected = (connection) => {
    if (connection === undefined || connection === null) {
      return false;
    }
    return connection.open === true;
  }

  const setCastPeerId = (id) => {
    console.log('Setting castPeerId');
    castPeerId = id;
    if (castPeerId && isConnected(castDataConnection) === false && USE_WEBRTC === true) {
      console.log('USING WEBRTC');
      castDataConnection = myPeer.connect(castPeerId, { serialization: 'json' });
      castDataConnection.on('open', onCommunicationChannelOpen);
      castDataConnection.on('data', (json) => {
          let parsed = JSON.parse(json);
          if (parsed.type === 'LC') {
            latencyChecker.onRecievedAnswer(parsed);
          } else {
            console.log('unknown data sent over WebRTC: ' + json);
          }
      });
    }
  }

  const launch = function () {
    if (currentSession || DEBUG) {
      console.log("running");
      if (USE_WEBRTC === false) {
        onCommunicationChannelOpen();
      } else {
        getCastPeerId();
      }
    } else {
      cleanup();
    }
  };

  const onCommunicationChannelOpen = () => {
    gamepad.disabled = false;
    if (initializeGame() === false && renderStateManager) {
      renderStateManager.sendInitializeState();
      resumeGame();
    }
    startCheckingLatency();
  };

  const startCheckingLatency = () => {
    latencyChecker.startChecking((payload) => {
      sendCastMessage({ ...payload, type: 'LC'});
    });
  };

  const initializeGame = () => {
    if (headlessGame) {
      return false;
    }
    renderStateManager = new PhaserRenderStateManager();
    renderStateManager.onStateChanged((delta) => {
        sendGameStateMessage(delta);
    });
    headlessGame = startGame(gamepad, renderStateManager);
    return true;
  };

  const onOpen = (id) => {
    console.log('Connected to Peer-server with id: ' + id);
  };

  const onClose = () => {
    console.log('Closed');
    cleanup();
    myPeer.destroy();
  };

  const onDisconnected = () => {
    console.log('disconnected');
    if (!castPeerId) {
      myPeer.reconnect();
    }
  };

  const onError = error => {
    console.log(error);
  };

  const cleanup = () => {
    console.log('Cleaning up');
    castPeerId = null;
    latencyChecker.stopChecking();
    pauseGame();
    if (currentSession) {
      currentSession.removeMessageListener(namespace, onCustomMessage);
      currentSession = null;
    }
    if (castDataConnection) {
      castDataConnection.close();
      castDataConnection = null;
    }
    gamepad.disabled = true;
  };

  const pauseGame = () => {
    if (headlessGame) {
      headlessGame.scene.sleep('breakout');
    }
  };

  const paused = () => {
    if (!headlessGame) {
      return false;
    }
    return headlessGame.scene.isSleeping('breakout');
  };

  const resumeGame = () => {
    if (headlessGame && currentSession) {
      headlessGame.scene.wake('breakout');
    } else if (headlessGame && !currentSession) {
      showConnectAlert();
    }
  };

  if (DEBUG) {
    launch();
  }
</script>
<script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>

</html>